name: 'Publish Release'

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

# Shared release body used by macOS, Windows, and Android build steps.
env:
  RELEASE_BODY: |
    ## What's New

    See the assets below to download and install this version.

    ### Downloads
    - **macOS (Apple Silicon)**: `.dmg` for M1/M2/M3/M4 Macs
    - **macOS (Intel)**: `.dmg` for Intel Macs
    - **Windows**: `.msi` installer or `.exe` setup
    - **Android**: `projex-release.apk` (requires "Install from unknown sources" enabled)

    ### Highlights
    - People CSV export/import: bulk export the people list to CSV and import/update from CSV with idempotent name-matching
    - S3 sync config export/import: export credentials to JSON for quick setup on a new device
    - Multi-device sync via S3-compatible storage (AWS S3, Cloudflare R2, MinIO, etc.)
    - Android background sync via WorkManager (periodic, ≥15 min interval)
    - Rich-text comments with Tiptap editor (bold, headings, task lists, tables, images)
    - Full i18n support: English and 中文 with live language switching
    - Application log viewer with redaction, search, and auto-refresh

jobs:
  # Run CI checks before publishing to prevent broken releases.
  pre-publish-ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Type check
        run: npx tsc -b --noEmit

      - name: Lint
        run: npm run lint

      - name: Install system dependencies (Linux)
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Rust tests
        working-directory: src-tauri
        run: cargo test

      - name: Rust format check
        working-directory: src-tauri
        run: cargo fmt --check

      - name: Clippy lint
        working-directory: src-tauri
        run: cargo clippy --all-targets --all-features -- -D warnings

  publish-tauri:
    needs: pre-publish-ci
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS ARM (M1+)
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
          # macOS Intel
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
          # Windows x64
          - platform: 'windows-latest'
            args: ''

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Import Apple Developer Certificate (macOS, optional)
        if: matrix.platform == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APPLE_CERTIFICATE_PASSWORD" ] || [ -z "$KEYCHAIN_PASSWORD" ]; then
            echo "Apple signing secrets not configured; skip certificate import."
            exit 0
          fi
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          security find-identity -v -p codesigning build.keychain

      - name: Resolve signing identity (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          IDENTITIES=$(security find-identity -v -p codesigning build.keychain 2>/dev/null || true)
          if [ -z "$IDENTITIES" ] || echo "$IDENTITIES" | grep -q "0 valid identities found"; then
            echo "No valid code signing identity found; using ad-hoc signing identity '-'"
            echo "APPLE_SIGNING_IDENTITY=-" >> $GITHUB_ENV
            exit 0
          fi
          CERT_ID=$(echo "$IDENTITIES" | head -n 1 | awk -F'"' '{print $2}')
          echo "APPLE_SIGNING_IDENTITY=$CERT_ID" >> $GITHUB_ENV
          echo "Using signing identity: $CERT_ID"

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install frontend dependencies
        run: npm ci

      - name: Build and release (macOS)
        if: matrix.platform == 'macos-latest'
        uses: tauri-apps/tauri-action@v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
        with:
          tagName: v__VERSION__
          releaseName: 'Projex v__VERSION__'
          releaseBody: ${{ env.RELEASE_BODY }}
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.args }}

      - name: Build and release (Windows)
        if: matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: v__VERSION__
          releaseName: 'Projex v__VERSION__'
          releaseBody: ${{ env.RELEASE_BODY }}
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.args }}

  # Build signed Android APK and upload to the GitHub Release.
  # Requires four repository secrets:
  #   ANDROID_KEYSTORE_BASE64   — base64-encoded .jks keystore file
  #   ANDROID_STORE_PASSWORD    — keystore password
  #   ANDROID_KEY_ALIAS         — key alias (e.g. "projex")
  #   ANDROID_KEY_PASSWORD      — key password
  publish-android:
    needs: pre-publish-ci
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android,armv7-linux-androideabi,x86_64-linux-android

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: android-release

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Android NDK
        run: |
          sdkmanager --install "ndk;29.0.14206865"
          echo "NDK_HOME=$ANDROID_HOME/ndk/29.0.14206865" >> $GITHUB_ENV

      - name: Decode keystore
        run: |
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 --decode > "$RUNNER_TEMP/projex-release.jks"
          echo "ANDROID_KEYSTORE_PATH=$RUNNER_TEMP/projex-release.jks" >> $GITHUB_ENV

      - name: Initialize Android project
        # `tauri android init` regenerates BuildTask.kt with the correct executable ("npm")
        # based on the current invocation context (npm_execpath is set by npm run).
        # BuildTask.kt is always overwritten by project::gen() — if we skip this step,
        # `tauri android build` may leave a stale BuildTask.kt that uses "cargo" instead
        # of "npm", causing Gradle's rustBuild* tasks to fail with "no such command: tauri".
        env:
          NDK_HOME: ${{ env.NDK_HOME }}
        run: npm run tauri -- android init --ci --skip-targets-install

      - name: Build signed release APK
        # tauri.settings.gradle is generated by tauri_build::build() (build.rs) only when
        # TAURI_ANDROID_PROJECT_PATH is set. This env var is set by the Tauri CLI internally
        # in get_config() before invoking cargo. Therefore we must use `tauri android build`
        # (not `cargo ndk` directly) so the full Tauri CLI pipeline runs:
        #   get_config() → sets TAURI_ANDROID_PROJECT_PATH
        #   → cargo build → build.rs → writes tauri.settings.gradle
        #   → gradlew assembleRelease (BuildTask calls npm run tauri android-studio-script)
        # Signing credentials are read from env vars in app/build.gradle.kts.
        env:
          NDK_HOME: ${{ env.NDK_HOME }}
          ANDROID_KEYSTORE_PATH: ${{ env.ANDROID_KEYSTORE_PATH }}
          ANDROID_STORE_PASSWORD: ${{ secrets.ANDROID_STORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: npm run tauri -- android build --apk --ci

      - name: Locate APK
        id: apk
        run: |
          APK=$(find src-tauri/gen/android/app/build/outputs/apk/release \
                     -name "*.apk" | head -1)
          echo "path=$APK" >> $GITHUB_OUTPUT
          echo "Found APK: $APK"

      - name: Rename APK to stable filename
        run: cp "${{ steps.apk.outputs.path }}" projex-release.apk

      - name: Upload APK to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ github.ref_name }}"
          # For workflow_dispatch without a tag, use the latest draft release.
          if [ -z "$TAG" ] || [ "$TAG" = "refs/heads/main" ]; then
            TAG=$(gh release list --repo "${{ github.repository }}" \
                    --limit 1 --json tagName --jq '.[0].tagName')
          fi
          gh release upload "$TAG" projex-release.apk \
            --repo "${{ github.repository }}" \
            --clobber

  publish-release:
    name: Publish GitHub Release (undraft)
    needs: [publish-tauri, publish-android]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    # Undraft only on tag push; workflow_dispatch leaves the release as draft
    # so it can be reviewed before going public.
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Publish release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release edit "${{ github.ref_name }}" \
            --repo "${{ github.repository }}" \
            --draft=false
